"""""""""""""""""""" original contents""""""""""""""""""""""""

set nocompatible

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" inoremap <C-s> <C-o>dw

""""""""""""""""" Section å…¨å±€è®¾ç½®"""""""""""""

" æ–‡ä»¶ç¼–ç 
set enc=utf-8
" ä¸è‡ªåŠ¨å¤‡ä»½ï¼Œç”Ÿæˆè®¨åŒçš„~
set nobackup

" ä¸ä½¿ç”¨swpæ–‡ä»¶
set noswapfile
" swpæ–‡ä»¶å•ç‹¬å­˜æ”¾, NOTE!!! è¿™ä¸ªç›®å½•è¦æ‰‹åŠ¨å»ºç«‹
set directory=${HOME}/.vimswapfiles//

let mapleader=";"

" vim è‡ªèº«å‘½ä»¤è¡Œæ¨¡å¼æ™ºèƒ½è¡¥å…¨
set wildmenu

" å¤šå­—èŠ‚å­—ç¬¦æ˜¾ç¤º
set ambiwidth=double

" vsplit always on right
set splitright

" åœ¨æ–°tabæˆ–å·²æœ‰tabä¸­æ‰“å¼€æ–‡æ¡£
set switchbuf+=usetab,newtab

""""""""""""""""""""""""""""""""""""""""""



""""""""""""""""" Section æ’ä»¶ç®¡ç†"""""""""""""""""

" å°† pathogen è‡ªèº«ä¹Ÿç½®äºç‹¬ç«‹ç›®å½•ä¸­ï¼Œéœ€æŒ‡å®šå…¶è·¯å¾„
runtime autoload/pathogen.vim
" è¿è¡Œ pathogen
execute pathogen#infect()

""""""""""""""""""""""""""""""""""""""""""



""""""""""""""" Helper Functions""""""""""""""""""
" æ ¡å‡†å…‰æ ‡ï¼Œä»tagbarç§»åŠ¨åˆ°ä¸»çª—å£
function! AdjustCursor()
    if (&ft == 'tagbar')
        " call feedkeys("\<C-w>\<Right>")
        execute "wincmd p"
    endif
    " check again, move cursor to right
    if (&ft == 'tagbar')
        execute "wincmd l"
    endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""



""""""""""""""""" Section æ˜¾ç¤º""""""""""""""""""""
" Maximize gvim window.
if has("gui_running")
    " GUI is running or is about to start.
    set lines=999 columns=999
endif

" è®¾ç½®å­—ä½“
" set guifont=YaHei_Consolas_Hybrid:h16:cANSI
set guifont=Consolas:h21

""" é…è‰²æ–¹æ¡ˆ
set background=dark
colorscheme molokai

"" ç¦æ­¢æ˜¾ç¤ºæ»šåŠ¨æ¡ scroll bar
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R
"" ç¦æ­¢æ˜¾ç¤ºèœå•å’Œå·¥å…·æ¡
" set guioptions-=m
set guioptions-=T

set laststatus=2 	" æ€»æ˜¯æ˜¾ç¤ºçŠ¶æ€æ 
set ruler			" æ˜¾ç¤ºå…‰æ ‡å½“å‰ä½ç½®
set nu	 			" å¼€å¯è¡Œå·æ˜¾ç¤º
set cursorline 		" é«˜äº®æ˜¾ç¤ºå½“å‰è¡Œ
set cursorcolumn	" é«˜äº®æ˜¾ç¤ºå½“å‰åˆ—
set nowrap 			" ç¦æ­¢æŠ˜è¡Œ

" è®¾ç½®çŠ¶æ€æ ä¸»é¢˜é£æ ¼
let g:Powerline_colorscheme='solarized256'

"" è¯­æ³•é«˜äº®
syntax enable 		" å¼€å¯è¯­æ³•é«˜äº®åŠŸèƒ½
syntax on 			" å…è®¸ç”¨æŒ‡å®šè¯­æ³•é«˜äº®é…è‰²æ–¹æ¡ˆæ›¿æ¢é»˜è®¤æ–¹æ¡ˆ

""" ç¼©è¿›
filetype indent on 	" è‡ªé€‚åº”ä¸åŒè¯­è¨€çš„æ™ºèƒ½ç¼©è¿›
set expandtab 		" å°†åˆ¶è¡¨ç¬¦æ‰©å±•ä¸ºç©ºæ ¼
set tabstop=4 		" è®¾ç½®ç¼–è¾‘æ—¶åˆ¶è¡¨ç¬¦å ç”¨ç©ºæ ¼æ•°
set shiftwidth=4 	" è®¾ç½®æ ¼å¼åŒ–æ—¶åˆ¶è¡¨ç¬¦å ç”¨ç©ºæ ¼æ•°
set softtabstop=4 	" è®© vim æŠŠè¿ç»­æ•°é‡çš„ç©ºæ ¼è§†ä¸ºä¸€ä¸ªåˆ¶è¡¨ç¬¦

function! SetIndent(...)
    let l:width = get(a:, 1, 4)
    let l:is_local = get(a:, 2, 0)
    if (l:is_local)
        let &l:tabstop = l:width
        let &l:shiftwidth = l:width
        let &l:softtabstop = l:width
    else
        execute 'set tabstop=' . l:width
        execute 'set shiftwidth=' . l:width
        execute 'set softtabstop=' . l:width
    endif
endfunction
command -nargs=* SetIndent call SetIndent(<f-args>)

"" ç¼©è¿›å¯è§†åŒ–æ’ä»¶ Indent Guides
let g:indent_guides_enable_on_vim_startup=1 		" éš vim è‡ªå¯åŠ¨
let g:indent_guides_start_level=2					" ä»ç¬¬äºŒå±‚å¼€å§‹å¯è§†åŒ–æ˜¾ç¤ºç¼©è¿›
let g:indent_guides_guide_size=1					" è‰²å—å®½åº¦
" å¿«æ·é”® im å¼€/å…³ç¼©è¿›å¯è§†åŒ–
nmap <silent> <Leader>im <Plug>IndentGuidesToggle

"" DetectIndent
let g:detectindent_preferred_expandtab = 1
let g:detectindent_preferred_indent = 4
let g:detectindent_preferred_when_mixed = 1
let g:detectindent_max_lines_to_analyse = 1024

""" ä»£ç æŠ˜å 
set foldmethod=syntax 		" åŸºäºç¼©è¿›æˆ–è¯­æ³•è¿›è¡Œä»£ç æŠ˜å 
set nofoldenable 			" å¯åŠ¨ vim æ—¶å…³é—­æŠ˜å ä»£ç 

""" ç¦æ­¢ plugin: YouCompleteMe è¯­æ³•é”™è¯¯é«˜äº®æ˜¾ç¤º
let g:ycm_enable_diagnostic_signs = 0
let g:ycm_enable_diagnostic_highlighting = 0
" let g:ycm_global_ycm_extra_conf='~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py'

""" Enable multiple highlights at startup ç”¨ä¸åŒé¢œè‰²é«˜äº®ä¸åŒå•è¯ highlights.vim
" æ¨¡æ‹Ÿé”®ç›˜æŒ‰é”®ï¼Œè¿™é‡Œä¸çŸ¥å¦‚ä½•å¼•ç”¨<leader>
autocmd VimEnter * nested :call feedkeys(";hi")

function! SaveHighlights(target_file, silent)
    Hsave xx
    execute "redir! > " . a:target_file
    execute "silent echo g:HI_SAVE_XX"
    execute "redir END"
    if (!a:silent)
        echo "Highlights saved"
    endif
endfunction
command -nargs=1 -complete=file Hs call SaveHighlights(<f-args>, 0)
nnoremap <Leader>hs :Hsave xx<CR>
nnoremap <Leader><Leader>hs :Hsave xx<CR>:call setreg('*', g:HI_SAVE_XX)<CR>

function! RestoreHighlights(target_file, silent)
    let g:HI_SAVE_XX = system("cat " . a:target_file)
    Hrestore xx
    if (!a:silent)
        echo "Highlights restored"
    endif
endfunction
command -nargs=1 -complete=file Hr call RestoreHighlights(<f-args>, 0)
nnoremap <Leader>hr :Hrestore xx<CR>
nnoremap <Leader><Leader>hr :let g:HI_SAVE_XX=@*<CR>:Hrestore xx<CR>

" rainbow plugin, bracket color
" let g:rainbow_active = 1
""""""""""""""""""""""""""""""""""""""""""""



""""""""""""""""""" Section æ§åˆ¶ Control""""""""""""""""""

" set mouse=a 			" å¼€å¯é¼ æ ‡åŠŸèƒ½, å¯ä»¥æ‹–åŠ¨çª—å£å¤§å°
filetype on 			" å¼€å¯æ–‡ä»¶ç±»å‹ä¾¦æµ‹
filetype plugin on 		" æ ¹æ®ä¾¦æµ‹åˆ°çš„ä¸åŒç±»å‹åŠ è½½å¯¹åº”çš„æ’ä»¶

" å®šä¹‰å¿«æ·é”®å…³é—­å½“å‰åˆ†å‰²çª—å£
nmap <silent> <Leader>qt :q<CR>
" å®šä¹‰å¿«æ·é”®ä¿å­˜å½“å‰çª—å£å†…å®¹
nmap <Leader>w :w<CR>
" å®šä¹‰å¿«æ·é”®ä¿å­˜æ‰€æœ‰çª—å£å†…å®¹å¹¶é€€å‡º vim
nmap <Leader>WQ :wa<CR>:q<CR>
" ä¸åšä»»ä½•ä¿å­˜ï¼Œç›´æ¥é€€å‡º vim
" nmap <Leader>Q :qa!<CR>

" Highlight without moving cursor
nnoremap <silent>* :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
" vnoremap <silent>* "ty:let @/='<C-r>t'<CR>:set hls<CR>
vnoremap <silent>* "ty:let @/=@t<CR>:set hls<CR>
nmap <silent># *
" vmap * y/\<\><Left><Left><C-r>0<CR>

" å¤åˆ¶é€‰åŒºåå…‰æ ‡ä¸åŠ¨
" vmap y ygv<ESC>
" è®¾ç½®å¿«æ·é”®å°†é€‰ä¸­æ–‡æœ¬å—å¤åˆ¶è‡³ç³»ç»Ÿå‰ªè´´æ¿
vnoremap <Leader>y "*y
" vmap <Leader>y "*ygv<ESC>
" è®¾ç½®å¿«æ·é”®å°†é€‰ä¸­æ–‡æœ¬å—å‰ªåˆ‡è‡³ç³»ç»Ÿå‰ªè´´æ¿
vnoremap <Leader>d "*d
" ç²˜è´´åå…‰æ ‡åœ¨æœ«å°¾
" nmap p pgp<ESC>
" vmap p pgp<ESC>
" nmap P Pgp<ESC>
" vmap P Pgp<ESC>
" è®¾ç½®å¿«æ·é”®å°†ç³»ç»Ÿå‰ªè´´æ¿å†…å®¹ç²˜è´´è‡³vim åœ¨å…‰æ ‡ä¹‹å
" nmap <Leader>p "+p
" nmap <Leader>p "*pgp<ESC>
" vmap <Leader>p "*pgp<ESC>
nnoremap <Leader>p "*p
vnoremap <Leader>p "*p
" è®¾ç½®å¿«æ·é”®å°†ç³»ç»Ÿå‰ªè´´æ¿å†…å®¹ç²˜è´´è‡³vim åœ¨å…‰æ ‡ä¹‹å‰
" nmap <Leader>P "+P
" nmap <Leader>P "*Pgp<ESC>
" vmap <Leader>P "*Pgp<ESC>
nnoremap <Leader>P "*P
vnoremap <Leader>P "*P
" é€‰ä¸­åˆšåˆšæ›´æ”¹çš„å¦‚ç²˜è´´, select just changed as paste
nnoremap <expr> gp '`[' . strpart(getregtype(), 0, 1) . '`]'
" Copy / cut to sys clipboard
nnoremap <Leader>yiw "*yiw
nnoremap <Leader>yiW "*yiW
nnoremap <Leader>diw "*diw
nnoremap <Leader>diW "*diW
nnoremap <Leader>yy "*yy
nnoremap <Leader>dd "*dd

" æ–‡æœ¬ç§»åŠ¨
" âˆ† = Alt-j Ëš = Alt-k
" To get the special char, in insert mode, press Ctrl-v,
" then press the shortcut key
nnoremap <silent> âˆ† :m .+1<CR>==
nnoremap <silent> Ëš :m .-2<CR>==
inoremap <silent> âˆ† <Esc>:m .+1<CR>==gi
inoremap <silent> Ëš <Esc>:m .-2<CR>==gi
vnoremap <silent> âˆ† :m '>+1<CR>gv=gv
vnoremap <silent> Ëš :m '<-2<CR>gv=gv

" åˆ é™¤è¡Œå°¾ç©ºæ ¼
nnoremap <silent><Leader>rtw :%s/\s\+$//<CR>:nohl<CR>
vnoremap <silent><Leader>rtw :s/\s\+$//<CR>:nohl<CR>
" åˆ é™¤ç©ºè¡Œ
nnoremap <silent><Leader>rel :g/^\s*$/d<CR>:nohl<CR>
vnoremap <silent><Leader>rel :g/^\s*$/d<CR>:nohl<CR>
" æ–­è¡Œ, split line
nnoremap K i<CR><Esc>

" å°†å¤–éƒ¨å‘½ä»¤ wmctrl æ§åˆ¶çª—å£æœ€å¤§åŒ–çš„å‘½ä»¤è¡Œå‚æ•°å°è£…æˆä¸€ä¸ª vim çš„å‡½æ•°
fun! ToggleFullscreen()
    call system("wmctrl -ir " . v:windowid . " -b toggle,fullscreen")
endf

nmap <silent><C-F11> :set wrap! linebreak nolist<CR>
" å…¨å±å¼€/å…³å¿«æ·é”®
nnoremap <F11> :call ToggleFullscreen()<CR>
"autocmd VimEnter * call ToggleFullscreen() 		" å¯åŠ¨ vim æ—¶è‡ªåŠ¨å…¨å±

" inoremap <c-s> <c-o>:w<CR>			" ctrl-s Save ä¿å­˜åè¿”å›åŸ(æ’å…¥)æ¨¡å¼ only work in gvim


""" å¤šæ–‡æ¡£ç¼–è¾‘ MiniBufExplorer
" disable auto open
let g:miniBufExplorerAutoStart = 0
let g:miniBufExplMaxSize = 1

" æ˜¾ç¤º/éšè— MiniBufExplorer çª—å£
nnoremap <silent><Leader>bl :MBEToggle<CR>
nnoremap <silent><S-F9> :MBEToggle<CR>
" close tab
nmap <leader>ct :MBEbd<CR>
"" buffer åˆ‡æ¢å¿«æ·é”®
nnoremap <C-Tab> :MBEbn<cr>
nnoremap <C-S-Tab> :MBEbp<cr>

""" plugin: NERDTree æ–‡ä»¶æµè§ˆå™¨
" autocmd VimEnter * nested :NERDTree				" å¯åŠ¨vimè‡ªåŠ¨å¼€å¯

""" Move cursor to Main window
" autocmd VimEnter * nested :wincmd h 				" left to main window
" autocmd VimEnter * nested :wincmd j 				" down to main
autocmd TabEnter * :call AdjustCursor()

""" æ–‡ä»¶ç®¡ç† plugin: NERDTree
" ä½¿ç”¨ NERDTree æ’ä»¶æŸ¥çœ‹å·¥ç¨‹æ–‡ä»¶ã€‚è®¾ç½®å¿«æ·é”®ï¼Œé€Ÿè®°ï¼šfile list
nmap <C-F10> :NERDTreeFind<CR>
nmap <F10> :NERDTreeToggle<CR>
" åœ¨æ–°tabæˆ–å·²æœ‰tabä¸­æ‰“å¼€æ–‡æ¡£
let NERDTreeCustomOpenArgs={'file': {'reuse':'all', 'where':'t'}}
let NERDTreeWinSize=40					" è®¾ç½® NERDTree å­çª—å£å®½åº¦
let NERDTreeWinPos="right"				" è®¾ç½® NERDTree å­çª—å£ä½ç½®
let NERDTreeMinimalUI=1					" NERDTree å­çª—å£ä¸­ä¸æ˜¾ç¤ºå†—ä½™å¸®åŠ©ä¿¡æ¯
let NERDTreeAutoDeleteBuffer=1			" åˆ é™¤æ–‡ä»¶æ—¶è‡ªåŠ¨åˆ é™¤æ–‡ä»¶å¯¹åº” buffer
let NERDTreeMapPreview='<CR>'        " open in current buffer
let NERDTreeMapOpenInTab='<Tab>'        " open in new tab
let NERDTreeMapPreviewSplit='<C-s>'        " open in h-split
let NERDTreeMapPreviewVSplit='<C-v>'        " open in v-split
let NERDTreeQuitOnOpen=3                " close after open file
" autocmd FileType nerdtree nmap <silent><buffer> <Esc> :q<CR>
autocmd FileType nerdtree nnoremap <silent><buffer> <Esc> :wincmd p<CR>:NERDTreeClose<CR>
" autocmd FileType nerdtree nmap <silent><buffer> <Space> <CR>:NERDTreeToggle<CR>
" filter
" let NERDTreeIgnore=['\.vim$', '^tags$', '^cscope\.', '\~$']
let NERDTreeIgnore=['^tags$', '^cscope\.', '\~$']

function OpenExplorer(...)
    let l:path = (a:0 >= 1) ? a:1 : getcwd()
    if isdirectory(l:path)
        silent execute "!open \"" . l:path . "\""
    else
        silent execute "!open -R \"" . l:path . "\""
    endif
endfunction

command -nargs=* -complete=file OpenExplorer call OpenExplorer(<f-args>)
nnoremap <silent> <D-F10> :call OpenExplorer()<CR>
nnoremap <silent> <S-D-F10> :call OpenExplorer(expand('%:p'))<CR>

function OpenTerminal(...)
    let l:dirname = (a:0 >= 1) ? a:1 : getcwd()
    silent execute "!open -a iTerm \"" . l:dirname . "\""
endfunction

command -nargs=* -complete=file OpenTerminal call OpenTerminal(<f-args>)
nnoremap <silent> <M-F10> :call OpenTerminal()<CR>
nnoremap <silent> <M-S-F10> :call OpenTerminal(expand('%:p:h'))<CR>

" F4 vim-buffer-manager
nnoremap <silent> <F4> :call CloseBufOrWin()<CR>
" nnoremap <silent> <F4> :bd<CR>
""" BufOnly.vim
" close all buffers except this vim-tab-manager
nnoremap <S-F4> :TabBufOnly<CR>
nnoremap <silent> <D-F4> :q<CR>
nnoremap <silent> <S-D-F4> :q!<CR>

""" åˆ†å‰²çª—å£ split window
nmap <leader>sp :sp<CR><C-w><Down>
nmap <leader>vs :vs<CR><C-w><Right>

" Move among splits
nnoremap <D-J> <C-w>j
nnoremap <D-K> <C-w>k
nnoremap <D-H> <C-w>h
nnoremap <D-L> <C-w>l
" S - A h/l
nnoremap Ã“ <C-w>h
nnoremap Ã’ <C-w>l
" S - A j/k
nnoremap Ã” <C-w>j
nnoremap ï£¿ <C-w>k
" split resize Alt <> +-
nnoremap â‰¤ <C-w><
nnoremap â‰¥ <C-w>>
nnoremap Â¯  12<C-w><
nnoremap Ë˜ 12<C-w>>
nnoremap <D-<> 12<C-w><
nnoremap <D->> 12<C-w>>
nnoremap â€“ <C-w>-
nnoremap â‰  <C-w>+
nnoremap â€” 5<C-w>-
nnoremap Â± 5<C-w>+
"" Reopen file in new tab
" nmap <Leader>tb :sp<CR><C-w>T
" Move tab
nnoremap <silent> <D-PageDown> :tabm +1<CR>
nnoremap <silent> <D-PageUp> :tabm -1<CR>
"" Alt + []
nmap â€œ <D-PageUp>
nmap â€˜ <D-PageDown>
nnoremap <silent> <S-D-PageDown> :tabmove<CR>
nnoremap <silent> <S-D-PageUp> :0tabmove<CR>
" Alt + {}
nmap â€ <S-D-PageUp>
nmap â€™ <S-D-PageDown>
nnoremap <silent> <S-C-PageUp> :tabfirst<CR>
nnoremap <silent> <S-C-PageDown> :tablast<CR>
" S-D-A-{}
nnoremap <silent> <D-â€> :tabfirst<CR>
nnoremap <silent> <D-â€™> :tablast<CR>
" Last active tab
" if !exists('g:Lasttab')
    " let g:Lasttab = 1
    " let g:Lasttab_backup = 1
" endif

" autocmd! TabLeave * let g:Lasttab_backup = g:Lasttab | let g:Lasttab = tabpagenr()
" autocmd! TabClosed * let g:Lasttab = g:Lasttab_backup
" nnoremap <silent> <Leader>lt :exe "tabn " . g:Lasttab<CR>
" nnoremap <silent> â€  :exe "tabn " . g:Lasttab<CR>

" scroll horizontally
nmap <S-C-Left> 9zh
nmap <S-C-Right> 9zl
nmap <S-Left> zH
nmap <S-Right> zL

function! ScrollDown()
    let distance = winheight(0) / 3
    let feedKeyStr = distance . "\<C-E>"
    call feedkeys(feedKeyStr)
endfunction

function! ScrollUp()
    let distance = winheight(0) / 3
    let feedKeyStr = distance . "\<C-Y>"
    call feedkeys(feedKeyStr)
endfunction

nmap <C-U> :call ScrollUp()<CR>
nmap <C-D> :call ScrollDown()<CR>

nmap <leader>qf :call ToggleQuickfixList()<CR>

" Span multi vertical splits
autocmd FileType qf :wincmd J
autocmd FileType qf nmap <buffer> 1 :colder<CR>
autocmd FileType qf nmap <buffer> 2 :cnewer<CR>
autocmd FileType qf nmap <buffer> ! :lolder<CR>
autocmd FileType qf nmap <buffer> @ :lnewer<CR>
nmap <silent> <C-k>  :cprev<CR>zz
nmap <silent> <C-j>  :cnext<CR>zz
" S-A-j/k jump between locationlist items
" nnoremap <silent> ï£¿ :lprev<CR>zz
" nnoremap <silent> Ã” :lnext<CR>zz

" For QuickFix and Locationlist window
" Space jump to item and close
" autocmd FileType qf nmap <silent><buffer> <space> <CR>:q<CR>:call AdjustCursor()<CR>
" Enter jump but not move out the window
" autocmd FileType qf nnoremap <silent><buffer> <CR> <CR><C-W><C-P>
" Esc for close
" autocmd FileType qf nmap <silent><buffer> <Esc> :q<CR>:call AdjustCursor()<CR>
autocmd FileType qf nmap <silent><buffer> <Esc> :wincmd p<CR>:ccl<CR>:call AdjustCursor()<CR>
autocmd FileType help nmap <silent><buffer> <Esc> :q<CR>:call AdjustCursor()<CR>
autocmd FileType gundo nmap <silent><buffer> <Esc> :q<CR>:call AdjustCursor()<CR>
" nnoremap <silent><Esc> <Esc>:lcl<CR>:ccl<CR>:pc<CR>:silent UniteClose<CR>:pwd<CR>
nnoremap <silent><Esc> <Esc>:lcl<CR>:ccl<CR>:pc<CR>:pwd<CR>
" nnoremap <silent><Esc> :lcl<CR>:ccl<CR>:pc<CR>:pwd<CR>

" For QFgrep
autocmd FileType qf nmap <buffer> <F2> :QFGrep<CR>
autocmd FileType qf nmap <buffer> <S-F2> <Plug>QFGrepV
autocmd FileType qf nmap <buffer> <F3> "tyiw:QFGrepPat \<<C-r>t\><CR>
autocmd FileType qf vmap <buffer> <F3> "ty:QFGrepPat \<<C-r>t\><CR>
autocmd FileType qf nmap <buffer> <S-F3> "tyiw:QFGrepPatV \<<C-r>t\><CR>
autocmd FileType qf vmap <buffer> <S-F3> "ty:QFGrepPatV \<<C-r>t\><CR>
autocmd FileType qf nmap <buffer> <F5> <Plug>QFRestore

""" Session
" goto home
function! SetHomeDir(...)
    if a:0 >= 1
        try
            execute "cd " . a:1
        catch
            echoerr "Cannot change cwd to " . a:1
        endtry
    endif
    let g:_home_directory = getcwd()
    echo 'HomeDir=' . g:_home_directory
endfunction

autocmd VimEnter * nested :let g:_home_directory = getcwd()
command! -nargs=* -complete=dir CD call SetHomeDir(<f-args>)
nnoremap <C-h> :cd `=g:_home_directory`<CR>:pwd<CR>

nnoremap <C-ScrollWheelDown> 9zl
nnoremap <C-ScrollWheelUp> 9zh
inoremap <C-ScrollWheelDown> <C-o>9zl
inoremap <C-ScrollWheelUp> <C-o>9zh

" Run shell cmd and read results
command! -nargs=* -complete=file ShellRead new | setlocal buftype=nofile bufhidden=hide noswapfile | read !<args>
cabbrev Sh ShellRead

" æ˜¾ç¤ºå½“å‰æ–‡ä»¶å…¨è·¯å¾„
" command Cf :echo @%

" airline
nnoremap <silent> <F12> :echo expand('%')<CR>
nnoremap <silent> <S-F12> :echo expand('%:p')<CR>
nnoremap <silent> <D-F12> :TagbarToggle<CR>
nnoremap <silent> <M-F12> :AirlineToggle<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""" Section æ–‡æœ¬ç¼–è¾‘ Text edit"""""""""""
" æ’å…¥æ—¶é—´æ—¥æœŸ
command Date :r !LANG=en_US.UTF-8 date

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""" Section æŸ¥æ‰¾æ›¿æ¢ Find & Replace""""""""""""""""""

" å–æ¶ˆæœç´¢ç»“æœé«˜äº®æ˜¾ç¤ºå¹¶åˆ·æ–°å±å¹•
nnoremap <silent> <C-l> :nohl<CR><C-l>
" nnoremap <silent> <C-l> :nohl<CR>
" nnoremap <silent> <C-h> :nohl<CR>
set incsearch 	" å¼€å¯å®æ—¶æœç´¢åŠŸèƒ½
set ignorecase 	" æœç´¢æ—¶å¤§å°å†™ä¸æ•æ„Ÿ
set smartcase   " å«æœ‰å¤§å†™å­—æ¯å¿½ç•¥ignorecase
set hlsearch 	" é«˜äº®æ˜¾ç¤ºæœç´¢ç»“æœ

""" é€‰å–å†…æŸ¥æ‰¾
function! RangeSearch(direction)
  call inputsave()
  let g:srchstr = input(a:direction)
  call inputrestore()
  if strlen(g:srchstr) > 0
    let g:srchstr = g:srchstr.
          \ '\%>'.(line("'<")-1).'l'.
          \ '\%<'.(line("'>")+1).'l'
  else
    let g:srchstr = ''
  endif
endfunction
vnoremap <silent> / :<C-U>call RangeSearch('/')<CR>:if strlen(g:srchstr) > 0\|exec '/'.g:srchstr\|endif<CR>
vnoremap <silent> ? :<C-U>call RangeSearch('?')<CR>:if strlen(g:srchstr) > 0\|exec '?'.g:srchstr\|endif<CR>

nmap <silent> <F3> *:vimgrep /<C-r>//j %<CR>:copen<CR>
vmap <silent> <F3> *:vimgrep /<C-r>//j %<CR>:copen<CR>

""" plugin: ack
" Disable result window key mapping
" let g:ack_apply_qmappings = 0
" let g:ack_apply_lmappings = 0
" nmap <silent> <D-F3> "tyiw:Ack! -rkw ""<Left><C-r>t<CR>/\<\><Left><Left><C-r>t<CR>
" vmap <silent> <D-F3> *:Ack! -rkw ""<Left><C-r>t<CR>
" nmap <M-D-F3> *:Ack! -rkw <cword> %:p:h<CR>
" vmap <M-D-F3> *:Ack! -rkw "" %:p:h<Left><Left><Left><Left><Left><Left><Left><C-r>t<CR>
" RipGrep
" let g:rg_highlight = 1
"" NOTE væ¨¡å¼ä¸‹ * é«˜äº®å·²ç»å°†æ–‡æœ¬å¤åˆ¶åˆ°tå¯„å­˜å™¨ä¸­
nmap <silent> <S-F3> *"tyiw:Rg -w <C-r>t<CR>
vmap <silent> <S-F3> *:EscapeStr t<CR>:Rg ''<Left><C-r>t<CR>
" find function call
nmap <Leader>fc *"tyiw:Rg -s '\b<C-r>t\('
nmap <Leader>mfc *"tyiw:Rg -s '[\.\\|\->]<C-r>t\('
nmap <silent> <M-F3> *"tyiw:Rg -w <C-r>t %:p:h<CR>
" vmap <silent> <M-F3> *"ty:Rg ''<Left><C-r>t<Right> %:p:h<CR>
vmap <silent> <M-F3> *:EscapeStr t<CR>:Rg ''<Left><C-r>t<Right> %:p:h<CR>
command! -bang -nargs=* FzfRg
    \ call fzf#vim#grep(
    \   'rg --column --line-number --no-heading --color=always --smart-case -- '.shellescape(<q-args>), 1,
    \   fzf#vim#with_preview('right:50%:hidden', 'F1'), <bang>0)
command! -bang -nargs=* FzfRgw
    \ call fzf#vim#grep(
    \   'rg -w --column --line-number --no-heading --color=always --smart-case -- '.shellescape(<q-args>), 1,
    \   fzf#vim#with_preview('right:50%:hidden', 'F1'), <bang>0)
nmap <silent> <S-D-F3> "tyiw:FzfRgw <C-r>t<CR>
vmap <silent> <S-D-F3> "ty:FzfRg <C-r>t<CR>

nmap <F2> :vimgrep //j % <bar> :copen<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
nmap <S-F2> :Rg ''<Left>
nmap <M-F2> :Rg '' %:p:h<Left><Left><Left><Left><Left><Left><Left>
" nmap <D-F2> :Ack! -rkwi "" %:p:h<Left><Left><Left><Left><Left><Left><Left>
" nmap <S-D-F2> :Ack! -rkwi ""<Left>
" nmap <leader>gr :Rgrep -wi  *<Left><Left>
" nmap <leader>ga :RgrepAdd -wi  *<Left><Left>
" nmap <leader>lgr :Rgrep -wi  *.h *.hpp *.cpp *.cc *.c *.cxx *.java *.py<Home><Right><Right><Right><Right><Right><Right><Right><Right><Right><Right>
nmap <leader>/ /\<\><Left><Left>
vmap <leader>/ /\<\><Left><Left>
nmap <leader><leader>/ :vimgrep /\<\>/j % <bar> :copen<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>

""" æ›¿æ¢
nnoremap <F5> :s/<C-r>///g<Left><Left>
vnoremap <F5> :s/\%V<C-r>///g<Left><Left>
nnoremap <S-F5> :%s/<C-r>///g<Left><Left>
" vnoremap <S-F5> :%s/<C-r>///g<Left><Left>

""" Search all open buffers
function GetBuffersList()
    let l:all = filter(range(1, bufnr('$')), 'buflisted(v:val)')
    let l:res = []
    for b in l:all
        call add(l:res, bufname(b))
    endfor
    return l:res
endfunction

function GrepAllBuffers(expression)
    try
        exec 'vimgrep /' . a:expression . '/j ' . join(GetBuffersList())
    catch
        echo "No match found!"
        return
    endtry
    exec 'copen'
endfunction
command -nargs=+ SearchBuffers call GrepAllBuffers(<q-args>)
nmap <silent> <F8> *:SearchBuffers <C-r>/<CR>
vmap <silent> <F8> *:SearchBuffers \<<C-r>/\><CR>
nmap <S-F8> :SearchBuffers \<\><Left><Left>
nmap <D-F8> :CtrlPBufTagAll<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""



"""""""""""""""""""""""""" Section ä»£ç å¯¼èˆª Code Nav""""""""""""""""""""""""""""
""""""" ctags
set csto=1      " Search tag file before cscope
" See http://vim.wikia.com/wiki/Single_tags_file_for_a_source_tree
set tags=.tags;
" å¼•ç”¨å…¶ä»–å·¥ç¨‹çš„tagsï¼Œç”Ÿæˆtagsè¦ç”¨å½“å‰å·¥ç¨‹ä¸ºç›¸å¯¹è·¯å¾„åŸºç¡€ï¼Œæˆ–ç”¨ç»å¯¹è·¯å¾„
" è‡ªåŠ¨åŠ è½½tagsè·¯å¾„è®¾ç½® .tags.vim ':set tags+=../../search_sf/sf/.tags,../public/index_query/.tags'
" check: echo &tags
" function! SetTags()
   " if filereadable(".tags.vim")
       " execute 'source! .tags.vim'
   " endif
" endfunction
" ctags -f .absl.tags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extras=+q --excmd=number ../abseil-cpp/absl
" :set tags+=.absl.tags   æ ¼å¼ .xxx.tags
" check: echo &tags
function! SetTags()
    let l:tags_file = glob("`ls -a | grep '^\\\.\.\\+\.tags$'`")
    execute 'set tags+=' . substitute(l:tags_file, "\n", ",", "g")
endfunction
autocmd VimEnter * nested :silent! call SetTags()<CR>

function! ResetTags()
    execute 'set tags=.tags;'
    call SetTags()
endfunction
command! ResetTags call ResetTags()

" nmap <Leader>ts yiw:ts <c-r>0<CR>
" vmap <Leader>ts y:ts /<c-r>0<CR>
" nmap <Leader>lt yiw:ltag <c-r>0<CR>:lopen<CR>/\<<C-r>0\><CR>
" vmap <Leader>lt y:ltag /<c-r>0<CR>:lopen<CR>/\<<C-r>0\><CR>
" nmap <space> <Leader>lt
" vmap <space> <Leader>lt
nmap <silent><F1> :call ToggleQuickfixList()<CR>:call AdjustCursor()<CR>
nmap <silent><S-F1> :call ToggleLocationList()<CR>:call AdjustCursor()<CR>
" location list å’Œ quickfix æŒ‰ç©ºæ ¼è·³è½¬åˆ°æ¡ç›®åè‡ªåŠ¨å…³é—­
" autocmd FileType qf nmap <buffer> <cr> <cr>:lcl<cr>

" jump in new tab
" nmap <C-\> "tyiw:tab ts <C-r>t<CR>
" vmap <C-\> "ty:tab ts <C-r>t<CR>
" jump in new split
" nmap <D-\> "tyiw:sts <C-r>t<CR>
" vmap <D-\> "ty:sts <C-r>t<CR>
" A-\ jump in new vsplit
" nmap Â« :vs<CR><C-w><Right>:exec("ts ".expand("<cword>"))<CR>
" vmap Â« "ty:vs<CR><C-w><Right>:ts <C-r>t<CR>

"""""""""""""

""""""" cscope
" è‡ªåŠ¨å¯»æ‰¾å¹¶æ·»åŠ å½“å‰ç›®å½•ä¸‹çš„æ•°æ®åº“
autocmd VimEnter * nested :cs add .
" å°†ç»“æœæ˜¾ç¤ºäºquickfix window
set cscopequickfix=s-,c-,d-,i-,t-,e-,g-
" find symbol
nnoremap  <leader>fs yiw:cs find s <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" find definition
nnoremap  <leader>fg yiw:cs find g <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" called by this
nnoremap  <leader>fd yiw:cs find d <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" call this
" nnoremap  <leader>fc yiw:cs find c <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" text
nnoremap  <leader>ft yiw:cs find t <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
vnoremap  <leader>ft y:cs find t <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" grep
nnoremap  <leader>fe yiw:cs find e <C-r>0<CR>:copen<CR>/<C-r>0<CR>
vnoremap  <leader>fe y:cs find e <C-r>0<CR>:copen<CR>/<C-r>0<CR>
" this file
nnoremap  <leader>ff yiw:cs find f <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>
" including this file
nnoremap  <leader>fi yiw:cs find i <C-r>0<CR>:copen<CR>/\<\><Left><Left><C-r>0<CR>

" nmap <S-space> <leader>fc
"""""""""""""""

""" æ¥å£ä¸å®ç°å¿«é€Ÿåˆ‡æ¢ plugin: a.vim
" *.cpp å’Œ *.h é—´åˆ‡æ¢
" nmap <silent> <Leader>ch :A<CR>
" å­çª—å£ä¸­æ˜¾ç¤º *.cpp æˆ– *.h
" nmap <silent> <Leader>sch :AS<CR>
" nmap <silent> <Leader>vch :AV<CR>
" nmap <silent> <Leader>tch :AT<CR>
nnoremap <silent> <D-\> :CppSwitchHdrSrc<CR>
" <S-D-\> = <D-\><Alt-m> switch and set to main window
nmap <silent> <D-Bar> <D-\>Âµ
" Alt + \
nmap <silent> Â« :CppSwitchHdrSrc s<CR>

""" è¿™ä¸¤ä¸ªåŠŸèƒ½æ˜¯vim tagåŠŸèƒ½ä¸€éƒ¨åˆ†
" æ­£å‘éå†åŒåæ ‡ç­¾
nmap <Leader>tn :tnext<CR>
" åå‘éå†åŒåæ ‡ç­¾
nmap <Leader>tp :tprevious<CR>

""" åŸºäºè¯­ä¹‰çš„ä»£ç å¯¼èˆª plugin: YouCompleteMe
nnoremap <leader>jd :YcmCompleter GoToDeclaration<CR>
" åªèƒ½æ˜¯ #include æˆ–å·²æ‰“å¼€çš„æ–‡ä»¶
nnoremap <leader>je :YcmCompleter GoToDefinition<CR>

""" æ ‡ç­¾åˆ—è¡¨ plugin: tagbar
" é»˜è®¤æŒ‰æºæ–‡ä»¶ä¸­å®šä¹‰é¡ºåºè€Œä¸æ˜¯å­—æ¯
let g:tagbar_sort = 0
" è®¾ç½® tagbar å­çª—å£çš„ä½ç½®å‡ºç°åœ¨ä¸»ç¼–è¾‘åŒºçš„å·¦è¾¹
let g:tagbar_position = 'left'
" è®¾ç½®æ˜¾ç¤ºï¼éšè—æ ‡ç­¾åˆ—è¡¨å­çª—å£çš„å¿«æ·é”®ã€‚é€Ÿè®°ï¼štag list
" è®¾ç½®æ ‡ç­¾å­çª—å£çš„å®½åº¦
let g:my_screen_width = winwidth(0)
let g:tagbar_width = g:my_screen_width / 7
" tagbar å­çª—å£ä¸­ä¸æ˜¾ç¤ºå†—ä½™å¸®åŠ©ä¿¡æ¯
let g:tagbar_compact = 1
let g:tagbar_indent = 1
" è®¾ç½® ctags å¯¹å“ªäº›ä»£ç å…ƒç´ ç”Ÿæˆæ ‡ç­¾
let g:tagbar_type_cpp = {
     \ 'ctagstype' : 'c++',
     \ 'kinds'     : [
         \ 'd:macros:1',
         \ 'g:enums',
         \ 't:typedefs:0:0',
         \ 'e:enumerators:0:0',
         \ 'n:namespaces',
         \ 'c:classes',
         \ 's:structs',
         \ 'u:unions',
         \ 'f:functions',
         \ 'm:members:0:0',
         \ 'v:global:0:0',
         \ 'x:external:0:0',
         \ 'l:local:0:0'
     \ ],
     \ 'sro'        : '::',
     \ 'kind2scope' : {
         \ 'g' : 'enum',
         \ 'n' : 'namespace',
         \ 'c' : 'class',
         \ 's' : 'struct',
         \ 'u' : 'union'
     \ },
     \ 'scope2kind' : {
         \ 'enum'      : 'g',
         \ 'namespace' : 'n',
         \ 'class'     : 'c',
         \ 'struct'    : 's',
         \ 'union'     : 'u'
     \ }
\ }
" Reset tagbar width
autocmd FileType tagbar nmap <silent><buffer> <Tab> :let g:tagbar_width = winwidth(0)<CR>:echo 'Set tagbar size to ' . winwidth(0)<CR>
"" tagbar auto open
" autocmd VimEnter * nested :TagbarOpen				" å¯åŠ¨vimè‡ªåŠ¨å¼€å¯
" å¯åŠ¨vimè‡ªåŠ¨å¼€å¯ä»…å¯¹æ‰€æ”¯æŒæ–‡ä»¶ç±»å‹
" autocmd VimEnter * nested :call tagbar#autoopen(1)
" åœ¨vimçª—å£æ‰“å¼€æ”¯æŒçš„æ–‡ä»¶
autocmd FileType * nested :call tagbar#autoopen(0)
" tabs
autocmd BufEnter * nested :call tagbar#autoopen(0)

" nmap <Tab> <Return>                            " é˜²æ­¢é¼ æ ‡åŒå‡»å¯¼è‡´ç¨‹åºå´©æºƒCtrl-I ä¸èƒ½å·¥ä½œ

""" cscope
" set cst					" ç”¨cscopeå®ç°ctagsåŠŸèƒ½ cscopetag
" autocmd VimEnter * nested :silent cs add cscope.out
" nnoremap <leader>fa :call cscope#findInteractive(expand('<cword>'))<CR>
nnoremap <leader>ll :call ToggleLocationList()<CR>
" s: Find this C symbol
" nnoremap  <leader>fs yiw:call cscope#find('s', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" g: Find this definition
" nnoremap  <leader>fg yiw:call cscope#find('g', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" d: Find functions called by this function
" nnoremap  <leader>fd yiw:call cscope#find('d', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" c: Find functions calling this function
" nnoremap  <leader>fc yiw:call cscope#find('c', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" t: Find this text string
" nnoremap  <leader>ft yiw:call cscope#find('t', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" vnoremap  <leader>ft y:call cscope#find('t', expand(''))<Left><Left><Left><C-r>0<CR>/\<\><Left><Left><C-r>0<CR>
" e: Find this egrep pattern
" nnoremap  <leader>fe yiw:call cscope#find('e', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" vnoremap  <leader>fe y:call cscope#find('e', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" f: Find this file
" nnoremap  <leader>ff yiw:call cscope#find('f', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" i: Find files #including this file
" nnoremap  <leader>fi yiw:call cscope#find('i', expand('<cword>'))<CR>/\<\><Left><Left><C-r>0<CR>
" æ›´æ–°æ•°æ®åº“
" nmap <F12> :cs kill -1<CR>:silent !myfind *.h*.hpp*.c*.cc*.cpp > cscope.files<CR>:silent !cscope -bkq -i cscope.files<CR>:cs add cscope.out<CR>:silent !cat cscope.files \| xargs ctags --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q<CR>:NeoCompleteTagMakeCache<CR><CR>
" nmap <F12> :cs kill -1<CR>:silent !myfind *.h*.hpp*.c*.cc*.cpp > cscope.files<CR>:silent !cscope -bkq -i cscope.files<CR>:cs add cscope.out<CR>:silent !cat cscope.files \| xargs ctags --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q<CR>:NeoCompleteTagMakeCache<CR>
" nmap <F12> :cs kill -1<CR>:!myfind *.h*.hpp*.c*.cc*.cpp > cscope.files<CR>:!cscope -bkq -i cscope.files<CR>:cs add cscope.out<CR><CR>
" nnoremap <F12> :silent !ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q .<CR>
" use universal-ctags instead of exuberant ctags
" brew install --HEAD universal-ctags/universal-ctags/universal-ctags
" nnoremap <C-F12> :silent !ctags -f .tags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q . && cscope -bkqR -i .cscope.files<CR>:cs kill -1<CR>:cs add .<CR>
" check cscope status :cs show
" kill all connections  :cs kill -1
" nnoremap <C-F12> :silent !ctags -f .tags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extras=+q --excmd=number . && cscope -bkqR -i .cscope.files<CR>:cs kill -1<CR>:cs add .<CR>
nnoremap <C-F12> :silent !ctags -f .tags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extras=+q --excmd=number .<CR>


""" ä»£ç æ”¶è— vim-signature
"" è‡ªå®šä¹‰ vim-signature å¿«æ·é”®
"let g:SignatureMap = {
        "\ 'Leader'             :  "m",
        "\ 'PlaceNextMark'      :  "m,",
        "\ 'ToggleMarkAtLine'   :  "m.",
        "\ 'PurgeMarksAtLine'   :  "m-",
        "\ 'DeleteMark'         :  "dm",
        "\ 'PurgeMarks'         :  "mda",
        "\ 'PurgeMarkers'       :  "m<BS>",
        "\ 'GotoNextLineAlpha'  :  "']",
        "\ 'GotoPrevLineAlpha'  :  "'[",
        "\ 'GotoNextSpotAlpha'  :  "`]",
        "\ 'GotoPrevSpotAlpha'  :  "`[",
        "\ 'GotoNextLineByPos'  :  "]'",
        "\ 'GotoPrevLineByPos'  :  "['",
        "\ 'GotoNextSpotByPos'  :  "mn",
        "\ 'GotoPrevSpotByPos'  :  "mp",
        "\ 'GotoNextMarker'     :  "[+",
        "\ 'GotoPrevMarker'     :  "[-",
        "\ 'GotoNextMarkerAny'  :  "]=",
        "\ 'GotoPrevMarkerAny'  :  "[=",
        "\ 'ListLocalMarks'     :  "ms",
        "\ 'ListLocalMarkers'   :  "m?"
        "\ }

""" code folding
set fdm=syntax

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



""""""""""""""""""""""""""" Section ä»£ç è‡ªåŠ¨å®Œæˆ Auto Complete"""""""""""""""""""""""""""

""" UltiSnips çš„ tab é”®ä¸ YCM å†²çªï¼Œé‡æ–°è®¾å®š
let g:UltiSnipsSnippetDirectories="vim-snippets/UltiSnips/"
let g:UltiSnipsExpandTrigger="<leader><tab>"
let g:UltiSnipsJumpForwardTrigger="<leader><tab>"
let g:UltiSnipsJumpBackwardTrigger="<leader><s-tab>"

""" YouCompleteMe
" Use homebrew's clangd
let g:ycm_clangd_binary_path = trim(system('brew --prefix llvm')).'/bin/clangd'
"" YCM è¡¥å…¨èœå•é…è‰²
" èœå•
highlight Pmenu ctermfg=2 ctermbg=3 guifg=#005f87 guibg=#EEE8D5
" é€‰ä¸­é¡¹
highlight PmenuSel ctermfg=2 ctermbg=3 guifg=#AFD700 guibg=#106900

" è¡¥å…¨åŠŸèƒ½åœ¨æ³¨é‡Šä¸­åŒæ ·æœ‰æ•ˆ
let g:ycm_complete_in_comments=1
" å…è®¸ vim åŠ è½½ .ycm_extra_conf.py æ–‡ä»¶ï¼Œä¸å†æç¤º
let g:ycm_confirm_extra_conf=0
" å¼€å¯ YCM æ ‡ç­¾è¡¥å…¨å¼•æ“
let g:ycm_collect_identifiers_from_tags_files=1
" å›è½¦å³é€‰ä¸­å½“å‰é¡¹ ycm
" inoremap <expr><CR> pumvisible() ? "\<C-y>" : "\<CR>"
" set tags+=/usr/include/c++/4.8/stdcpp.tags 		 			" å¼•å…¥ C++ æ ‡å‡†åº“ tags
" YCM é›†æˆ OmniCppComplete è¡¥å…¨å¼•æ“ï¼Œè®¾ç½®å…¶å¿«æ·é”®
inoremap <leader>; <C-x><C-o>
" è¡¥å…¨å†…å®¹ä¸ä»¥åˆ†å‰²å­çª—å£å½¢å¼å‡ºç°ï¼Œåªæ˜¾ç¤ºè¡¥å…¨åˆ—è¡¨
set completeopt-=preview
" ä»ç¬¬ä¸€ä¸ªé”®å…¥å­—ç¬¦å°±å¼€å§‹ç½—åˆ—åŒ¹é…é¡¹
let g:ycm_min_num_of_chars_for_completion=1
" ç¦æ­¢ç¼“å­˜åŒ¹é…é¡¹ï¼Œæ¯æ¬¡éƒ½é‡æ–°ç”ŸæˆåŒ¹é…é¡¹
let g:ycm_cache_omnifunc=0
" è¯­æ³•å…³é”®å­—è¡¥å…¨
let g:ycm_seed_identifiers_with_syntax=1
" å…¨å±€é…ç½®æ–‡ä»¶
let ycm_global_ycm_extra_conf="~/.vim/bundle/YouCompleteMe/third_party/ycmd/examples/.ycm_extra_conf.py"

" ç¦æ­¢è‡ªåŠ¨å¼¹å‡ºå¸®åŠ©æ–‡æ¡£
let g:ycm_auto_hover = ''
" å¸®åŠ©ç¨³å®š pop up çª—å£ c++ è¯­æ³•é«˜äº®
augroup MyYCMCustom
autocmd!
autocmd FileType c,cpp let b:ycm_hover = {
  \ 'command': 'GetDoc',
  \ 'syntax': &filetype
  \ }
augroup END

""" æ³¨é‡Š NERDCommenter
" æ³¨é‡Šç¬¦åè·Ÿä¸€ä¸ªç©ºæ ¼
let NERDSpaceDelims = 1

""" vim-go
"" first make sure env vars were set
" export GOROOT=/usr/local/Cellar/go/1.17.2/libexec
" export GOPATH=/Users/sunchao11/go
"" then in vim run GoInstallBinaries or only run 'GoUpdateBinaries gopls'
let g:go_fmt_fail_silently = 1

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


"""""""""""Section ä»£ç æ’ç‰ˆ""""""""""""""""""""""

"""""""Easy Align
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

"""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""" Section vim-bookmarks""""""""""""""""""

nmap <Leader>mm :BookmarkToggle<CR>
nmap <Leader>mi :BookmarkAnnotate<CR>
" nmap <Leader>m/ :BookmarkShowAll<CR>
nmap <Leader>m/ :CtrlPBookmark<CR>
nnoremap <C-b> :FZFBookmarks<CR>
nmap <F6> :BookmarkNext<CR>
nmap <S-F6> :BookmarkPrev<CR>
nmap <M-F6> :BookmarkMoveDown<CR>
nmap <M-S-F6> :BookmarkMoveUp<CR>
" nmap <Leader>mc :BookmarkClear<CR>
" nmap <Leader>mx :BookmarkClearAll<CR>
" nmap <Leader>mkk :BookmarkMoveUp<CR>
" nmap <Leader>mjj :BookmarkMoveDown<CR>

" let g:bookmark_auto_save = 0
let g:bookmark_save_per_working_dir = 1
let g:bookmark_no_default_key_mappings = 1
let g:bookmark_highlight_lines = 1
" Turn off the warning when clearing all bookmarks
let g:bookmark_show_warning = 0
" Turn off the warning when toggling to clear a bookmark with annotation
let g:bookmark_show_toggle_warning = 0
" Turn on vertical line centering when jumping to bookmark
let g:bookmark_center = 1
" use location list
" let g:bookmark_location_list = 1
" highlight BookmarkSign ctermbg=NONE ctermfg=160
" highlight BookmarkLine ctermbg=194 ctermfg=NONE
let g:bookmark_sign = 'ğŸ'
let g:bookmark_annotation_sign = 'ğŸ'
let g:bookmark_highlight_lines = 1

" call unite#custom#profile('source/vim_bookmarks', 'context', {
    " \   'winheight': 50,
    " \   'direction': 'belowright',
    " \   'start_insert': 0,
    " \   'keep_focus': 1,
    " \   'no_quit': 0,
    " \ })

" command Sm :BookmarkSave bookmark.vim
" command Lm :BookmarkLoad bookmark.vim
" command Bmc :BookmarkClear
" command Bmca :BookmarkClearAll

" function! AutoSaveBookmark()
   " if filereadable("bookmark.vim")
       " execute "!cp bookmark.vim bookmark.vim~"
       " execute 'Sm'
   " endif
" endfunction
" autocmd VimLeave * :call AutoSaveBookmark()

"""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""" Unite""""""""""""""""""""""""""""
nnoremap <Leader>ub :Unite buffer -direction=belowright<CR>
nnoremap <Leader>uf :Unite file -direction=belowright<CR>
nnoremap <Leader>ur :Unite file_rec -direction=belowright<CR>
nnoremap <S-F10> :Unite file_rec -direction=belowright<CR>
" nnoremap <silent> <M-F9> :UniteResume<CR>
nnoremap <silent> <M-F9> :FZF %:p:h<CR>
nnoremap <Leader>us :UniteResume<CR>
nnoremap <Leader>un :UniteNext<CR>
nnoremap <Leader>up :UnitePrevious<CR>
" In unite window, press Esc to quit
autocmd FileType unite nmap <silent><buffer> <Esc> :UniteClose<CR>:call AdjustCursor()<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""CtrlP""""""""""""""""""""""""
let g:ctrlp_cmd = 'CtrlP .'
let g:ctrlp_open_multiple_files = 'i'
let g:ctrlp_extensions = ['smarttabs']
let g:ctrlp_match_window = 'max:20,results:100'
let g:ctrlp_mruf_max = 500

""" ctrlp-bdelete
call ctrlp_bdelete#init()

nnoremap <C-F9> :CtrlP %:p:h<CR>
nnoremap <D-F9> :CtrlPSmartTabs<CR>
nnoremap <F9> :CtrlPMRU<CR>
nnoremap <silent> <C-f> :FZF<CR>
nnoremap <silent> <C-a> :CtrlPBuffer<CR>
" nnoremap <silent> <D-F1> :CtrlPBufTag<CR>
" nnoremap <silent> <M-F1> :CtrlPQuickfix<CR>
nnoremap <silent> <C-D-F1> :CtrlPBufTagAll<CR>
nmap <silent> <C-F1> <C-f><CR>
"" open in new tab
" let g:ctrlp_prompt_mappings = {
    " \ 'AcceptSelection("e")': [],
    " \ 'AcceptSelection("t")': ['<cr>', '<c-m>'],
    " \ }
let g:ctrlp_prompt_mappings = {
    \ 'AcceptSelection("t")': ['<c-t>', '<Tab>'],
    \ }
"""""""""""""""""""""""""""""""""""""""""""""""""""


""""""""""""""""""""""fzf""""""""""""""""""""""""""
" set rtp+=~/.fzf
" let g:fzf_preview_window = 'right:60%'
let g:fzf_history_dir = '~/.local/share/fzf-history'
let g:fzf_buffers_jump = 1

function! s:GotoOrOpen(command, ...)
    for file in a:000
        if a:command == 'e'
            exec 'tabe ' . file
        else
            exec "tab drop " . file
        endif
    endfor
endfunction
command! -nargs=+ GotoOrOpen call s:GotoOrOpen(<f-args>)

" TabDrop in vim-buffer-manager
let g:fzf_action = {
  \ 'Enter': 'tab split',
  \ 'ctrl-t': 'tab split',
  \ 'Tab': 'TabDrop',
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

nnoremap <F7> :FZFTags<CR>
nnoremap <C-\> "tyiw:FZFTags <C-r>t<CR>
vnoremap <C-\> "ty:FZFTags <C-r>t<CR>
nnoremap <S-F7> "tyiw:FZFTags! <C-r>t<CR>
vnoremap <S-F7> "ty:FZFTags! <C-r>t<CR>
nnoremap <silent> <D-F1> :BTags<CR>
nnoremap <silent> <S-D-F1> :BTags!<CR>
nnoremap <M-F1> "tyiw:BTags <C-r>t<CR>
vnoremap <M-F1> "ty:BTags <C-r>t<CR>
nnoremap <M-F7> :Lines<CR>
nnoremap <D-F7> :Buffers<CR>
autocmd FileType qf nnoremap <buffer> <D-F1> :FZFQuickFix<CR>
"""""""""""""""""""""""""""""""""""""""""""""""""""


"""""""""""""""""""""Others""""""""""""""""""""""""
" åˆ‡æ¢è·¯å¾„åˆ°å½“å‰æ‰€ç¼–è¾‘æ–‡ä»¶æ‰€åœ¨ç›®å½•
" nnoremap <Leader>cwd :cd %:p:h<CR>:pwd<CR>
""" airline
" tagbar
let g:airline#extensions#tagbar#enabled = 1
" tab
" let g:airline#extensions#tabline#enabled = 1

function! GenBazelStr()
    normal! vi""ty
    let l:cur_word = getreg('t')
    let l:cur_dir = expand('%:h')
    if l:cur_dir == '.'
        let l:cur_dir = ''
    endif
    let l:bazelStr = "//" . l:cur_dir . ":" . l:cur_word
    call setreg("*", l:bazelStr, "c")
    echo "Saved bazel item " . l:bazelStr . " to clipboard"
endfunction
command! Bazel call GenBazelStr()

"""""""""""""""""""""""""""""""""""""""""""""""""""


" æ›¿æ¢

" æ›¿æ¢å‡½æ•°ã€‚å‚æ•°è¯´æ˜ï¼š
" confirmï¼šæ˜¯å¦æ›¿æ¢å‰é€ä¸€ç¡®è®¤
" wholewordï¼šæ˜¯å¦æ•´è¯åŒ¹é…
" replaceï¼šè¢«æ›¿æ¢å­—ç¬¦ä¸²
function! Replace(confirm, wholeword, replace)
    wa
    let flag = ''
    if a:confirm
        let flag .= 'gec'
    else
        let flag .= 'ge'
    endif
    let search = ''
    if a:wholeword
        let search .= '\<' . escape(expand('<cword>'), '/\.*$^~[') . '\>'
    else
        let search .= expand('<cword>')
    endif
    let replace = escape(a:replace, '/\&~')
    execute 'argdo %s/' . search . '/' . replace . '/' . flag . '| update'
endfunction
" ä¸ç¡®è®¤ã€éæ•´è¯
nnoremap <Leader>R :call Replace(0, 0, input('Replace '.expand('<cword>').' with: '))<CR>
" ä¸ç¡®è®¤ã€æ•´è¯
nnoremap <Leader>rw :call Replace(0, 1, input('Replace '.expand('<cword>').' with: '))<CR>
" ç¡®è®¤ã€éæ•´è¯
nnoremap <Leader>rc :call Replace(1, 0, input('Replace '.expand('<cword>').' with: '))<CR>
" ç¡®è®¤ã€æ•´è¯
nnoremap <Leader>rcw :call Replace(1, 1, input('Replace '.expand('<cword>').' with: '))<CR>
nnoremap <Leader>rwc :call Replace(1, 1, input('Replace '.expand('<cword>').' with: '))<CR>



" <<

" é™æ€åˆ†æå™¨ syntastic é”™è¯¯æ ‡è¯†
let g:syntastic_error_symbol = 'âœ—'
let g:syntastic_warning_symbol = 'âš '

" >>
" ç”±æ¥å£å¿«é€Ÿç”Ÿæˆå®ç°æ¡†æ¶

" è®¾ç½® pullproto.pl è„šæœ¬è·¯å¾„
" let g:protodefprotogetter='~/.vim/bundle/vim-protodef/pullproto.pl'

" æˆå‘˜å‡½æ•°çš„å®ç°é¡ºåºä¸å£°æ˜é¡ºåºä¸€è‡´
" let g:disable_protodef_sorting=1


" ç¯å¢ƒæ¢å¤

" è®¾ç½®ç¯å¢ƒä¿å­˜é¡¹
" set sessionoptions="blank,globals,localoptions,tabpages,sesdir,folds,help,options,resize,winpos,winsize"

" ä¿å­˜ undo å†å²
set undodir=~/.undo_history/
set undofile

" è°ƒç”¨ gundo æ ‘
nnoremap <Leader>ud :GundoToggle<CR>

" >>
" web å‰ç«¯

" surrond æ·»åŠ  <p> å…ƒç´ çš„å¿«æ·é”®
" nmap <Leader>ap yss<p><CR>

" å¯¹ HTML å…ƒç´ è¿›è¡Œè½¬ä¹‰ï¼š< -> &lt;ã€> -> &gt;ã€& -> &amp;ã€ç©ºæ ¼ -> &nbsp;ã€è¡Œå°¾æ·»åŠ  <br />
" å…ˆåé¡ºåºæ•æ„Ÿ
" function HtmlEscape()
    " retab<CR>
    " silent s/&/\&amp;/eg
    " silent s/</\&lt;/eg
    " silent s/>/\&gt;/eg
    " silent s/ /\&nbsp;/eg
    " silent s/$/<br \/>/eg
" endfunction
" vnoremap <Leader>he :call HtmlEscape()<CR>

" <<

" let OmniCpp_DefaultNamespaces = ["_GLIBCXX_STD"]



